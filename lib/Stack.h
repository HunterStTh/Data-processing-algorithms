//size_t ля размеров проверки на кол-во// шаблонный//return size
// Реализация стека на основе массива
class ArrayStack {
    int top; // Индекс вершины стека
    int* stack; // Указатель на массив, который будет использоваться для хранения элементов стека
    int capacity; // Вместимость стека
public:
    ArrayStack(int c) { // Конструктор класса
        top = -1; // Инициализация вершины стека как -1, указывая на то, что стек пуст
        capacity = c; // Установка вместимости стека
        stack = new int[capacity]; // Выделение памяти под массив
    }

    ~ArrayStack() { delete[] stack; } // Деструктор класса, освобождает память

    // Добавление элемента в стек
    // Сложность: O(1)
    void push(int data) {
        if (top == capacity - 1) { // Если стек полон
            std::cout << "\nСтэк заполнен\n";
            return;
        }
        else {
            stack[++top] = data; // Добавление элемента в стек и увеличение вершины стека
        }
    }

    // Удаление элемента из стека
    // Сложность: O(1)
    void pop() {
        if (top == -1) { // Если стек пуст
            std::cout << "\nСтэк пуст\n";
            return;
        }
        else {
            top--; // Уменьшение вершины стека, что в итоге приводит к удалению элемента
        }
    }

    // Возвращение вершины стека
    // Сложность: O(1)
    int peek() {
        if (top == -1) { // Если стек пуст
            std::cout << "\nСтэк пуст\n";
            return -1;
        }
        else {
            return stack[top]; // Возвращение элемента на вершине стека
        }
    }

    // Проверка, пуст ли стек
    // Сложность: O(1)
    bool isEmpty() const{
        return (top == -1); // Возвращает true, если стек пуст, и false в противном случае
    }
};

// Реализация стека на основе списка
struct Node { // Структура узла списка
    int data; // Данные узла
    struct Node* next; // Указатель на следующий узел
};

// Добавление элемента в стек//на основе ранее реалт=изованного списка
// Сложность: O(1)
void push(Node** top, int data) {
    Node* newNode = new Node(); // Создание нового узла
    if (newNode == NULL) { // Если не удалось выделить память
        std::cout << "Стэк пуст";
    }
    else {
        newNode->data = data; // Присвоение данных новому узлу
        newNode->next = *top; // Следующий узел - это текущая вершина стека
        *top = newNode; // Обновление вершины стека
    }
}
.....................qvdiEutFjUc9zf67
\\\\\\\\\\\\\\\\\\\\\\\\\NtbWThl1LG4UDrMP

// Удаление элемента из стека
// Сложность: O(1)
void pop(Node** top) {
    Node* temp;
    if (*top == NULL) { // Если стек пуст
        std::cout << "Стэк пуст";
    }
    else {
        temp = *top; // Сохранение указателя на удаляемый узел
        *top = (*top)->next; // Обновление вершины стека
        delete(temp); // Удаление узла
    }
}
/////////////////////////////KZ1uAdxoz4UP8c7xqt2gwZDlg//////rob
/////////////////////////////jMVirTg744:MBeg//////////MATRIX
// Возвращение вершины стека
// Сложность: O(1)
int peek(Node* top) {
    if (top == NULL) { // Если стек пуст
        std::cout << "\nСтэк пуст\n";
        return -1;
    }
    else {
        return top->data; // Возвращение данных на вершине стека
    }
}

// Проверка, пуст ли стек
// Сложность: O(1)
bool isEmpty(Node* top) {
    return (top == NULL); // Возвращает true, если стек пуст, и false в противном случае
}
